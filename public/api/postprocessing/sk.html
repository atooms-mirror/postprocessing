<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>postprocessing.sk API documentation</title>
<meta name="description" content="Structure factor." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>postprocessing.sk</code></h1>
</header>
<section id="section-intro">
<p>Structure factor.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of atooms
# Copyright 2010-2018, Daniele Coslovich

&#34;&#34;&#34;Structure factor.&#34;&#34;&#34;

import logging
import numpy

from .progress import progress
from .fourierspace import FourierSpaceCorrelation, expo_sphere

__all__ = [&#39;StructureFactor&#39;, &#39;StructureFactorLegacy&#39;, &#39;StructureFactorOptimized&#39;, &#39;StructureFactorFast&#39;]

_log = logging.getLogger(__name__)


def is_cell_variable(trajectory, tests=1):
    &#34;&#34;&#34;
    Simple test to check if cell changes.

    We compare the first frame to an integer number `tests` of other
    frames starting from the end of `trajectory`.
    &#34;&#34;&#34;
    is_variable = False
    frames = len(trajectory)
    if tests &gt; 0:
        skip = max(1, int(frames / float(tests)))
    else:
        skip = 1
    L0 = trajectory[0].cell.side
    for sample in range(frames-1, 0, -skip):
        cell = trajectory[sample].cell
        L1 = cell.side
        if numpy.any(L0 != L1):
            is_variable = True
            break
    return is_variable


class StructureFactorLegacy(FourierSpaceCorrelation):
    &#34;&#34;&#34;
    Structure factor.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;sk&#39;
    short_name = &#39;S(k)&#39;
    long_name = &#39;structure factor&#39;
    phasespace = [&#39;pos&#39;]

    def __init__(self, trajectory, kgrid=None, norigins=-1, nk=20,
                 dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30):
        FourierSpaceCorrelation.__init__(self, trajectory, kgrid, norigins,
                                         nk, dk, kmin, kmax, ksamples)
        self._is_cell_variable = None

    def _compute(self):
        nsteps = len(self._pos_0)
        ndims = len(self.k0)
        kgrid = self.kgrid
        
        # Setup k vectors and tabulate rho
        cnt = [0 for k in kgrid]
        rho_0_av = [complex(0., 0.) for k in kgrid]
        rho_1_av = [complex(0., 0.) for k in kgrid]
        rho2_av = [complex(0., 0.) for k in kgrid]
        variable_cell = is_cell_variable(self.trajectory)
        for i in progress(range(0, nsteps, self.skip), total=nsteps // self.skip):
            # If cell changes we have to update the wave vectors
            if variable_cell:
                self._setup(i)

            # Tabulate exponentials
            # Note: tabulating and computing takes about the same time
            if self._pos_0[i] is self._pos_1[i]:
                # Identical species
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_0
            else:
                # Cross correlation
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[i])

            # Define weights
            if self._weight is None:
                weight_0, weight_1 = 1.0, 1.0
            else:
                weight_0, weight_1 = self._weight_0[i], self._weight_1[i]

            # Nice spaghetti here
            for k, klist in enumerate(self._kvectors):
                for kvec in klist:
                    if expo_0 is expo_1:
                        # Identical species
                        if ndims == 3:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]] *
                                              expo_0[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]])
                        else:
                            tmp = weight_0 * expo_0[..., 0, kvec[0]]
                            for idim in range(1, ndims):
                                tmp *= expo_0[..., idim, kvec[idim]]
                            rho_0 = numpy.sum(tmp)

                        rho_1 = rho_0
                    else:
                        # Cross correlation
                        if ndims == 3:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]] *
                                              expo_0[..., 2, kvec[2]])
                            rho_1 = numpy.sum(weight_1 *
                                              expo_1[..., 0, kvec[0]] *
                                              expo_1[..., 1, kvec[1]] *
                                              expo_1[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]])
                            rho_1 = numpy.sum(weight_1 *
                                              expo_1[..., 0, kvec[0]] *
                                              expo_1[..., 1, kvec[1]])
                        else:
                            tmp = weight_0 * expo_0[..., 0, kvec[0]]
                            for idim in range(ndims):
                                tmp *= expo_0[..., idim, kvec[idim]]
                            rho_0 = numpy.sum(tmp)
                            tmp = weight_0 * expo_1[..., 0, kvec[0]]
                            for idim in range(ndims):
                                tmp *= expo_1[..., idim, kvec[idim]]
                            rho_1 = numpy.sum(tmp)

                    # Cumulate averages
                    rho_0_av[k] += rho_0
                    rho_1_av[k] += rho_1
                    rho2_av[k] += (rho_0 * rho_1.conjugate())
                    cnt[k] += 1

        # In the absence of a microscopic field, the average density is zero.
        # We get rid of the average and compute &lt;rho(k)rho*(k)&gt;.
        if self._weight_0 is None:
            rho_0_av = [complex(0., 0.) for k in kgrid]
            rho_1_av = [complex(0., 0.) for k in kgrid]

        # Normalization
        npart_0 = sum([p.shape[0] for p in self._pos_0]) / float(len(self._pos_0))
        npart_1 = sum([p.shape[0] for p in self._pos_1]) / float(len(self._pos_1))
        self.grid = kgrid
        self.value, self.value_nonorm = [], []
        for k in range(len(self.grid)):
            norm = float(npart_0 * npart_1)**0.5
            value = (rho2_av[k] / cnt[k] - rho_0_av[k] * rho_1_av[k].conjugate() / cnt[k]**2).real
            self.value.append(value / norm)
            self.value_nonorm.append(value)


class StructureFactorFast(StructureFactorLegacy):
    &#34;&#34;&#34;
    Optimized structure factor.

    It uses a fortran 90 extension.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;sk&#39;
    short_name = &#39;S(k)&#39;
    long_name = &#39;structure factor&#39;
    phasespace = [&#39;pos&#39;]

    def _compute(self):
        from atooms.trajectory.utils import is_cell_variable
        try:
            from atooms.postprocessing.fourierspace_wrap import fourierspace_module
        except ImportError:
            _log.error(&#39;f90 wrapper missing or not functioning&#39;)
            raise

        nsteps = len(self._pos_0)
        kgrid = self.kgrid

        # Setup k vectors and tabulate rho
        cnt = [0 for k in kgrid]
        rho_av = [complex(0., 0.) for k in kgrid]
        rho2_av = [complex(0., 0.) for k in kgrid]
        variable_cell = is_cell_variable(self.trajectory)
        for i in range(0, nsteps, self.skip):
            # If cell changes we have to update the wave vectors
            if variable_cell:
                self._setup(i)

            # Tabulate exponentials
            # Note: tabulating and computing takes about the same time
            if self._pos_0[i] is self._pos_1[i]:
                # Identical species
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_0
            else:
                # Cross correlation
                # TODO: cross correlation wont work
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[i])

            # for kk, knorm in enumerate(kgrid):
            #     ikvec = numpy.ndarray((3, len(selection[kk])), order=&#39;F&#39;, dtype=numpy.int32)
            #     i = 0
            #     for k in selection[kk]:
            #         ikvec[:, i] = self.kvector[knorm][k]
            #         i += 1
            for k, klist in enumerate(self._kvectors):
                # TODO: do it by transpose()
                # Fill array of kvectors in this bin
                ikvec = numpy.ndarray((3, len(klist)), order=&#39;F&#39;, dtype=numpy.int32)
                for i, kvec in enumerate(klist):
                    ikvec[:, i] = kvec
                rho = numpy.zeros(ikvec.shape[1], dtype=numpy.complex128)
                fourierspace_module.sk_bare(expo_0, ikvec, rho)
                rho_0 = rho
                rho_1 = rho
                rho2_av[k] += numpy.sum(rho_0 * rho_1.conjugate())
                cnt[k] += rho.shape[0]

        # Normalization.
        npart_0 = sum([p.shape[0] for p in self._pos_0]) / float(len(self._pos_0))
        npart_1 = sum([p.shape[0] for p in self._pos_1]) / float(len(self._pos_1))
        self.grid = kgrid
        self.value, self.value_nonorm = [], []
        for k in range(len(self.grid)):
            norm = float(npart_0 * npart_1)**0.5
            value = (rho2_av[k] / cnt[k] - rho_av[k]*rho_av[k].conjugate() / cnt[k]**2).real
            self.value.append(value / norm)
            self.value_nonorm.append(value)


# Defaults to legacy
StructureFactor = StructureFactorLegacy
# Backward compatible alias
StructureFactorOptimized = StructureFactorFast</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="postprocessing.sk.StructureFactorFast"><code class="flex name class">
<span>class <span class="ident">StructureFactorOptimized</span></span>
<span>(</span><span>trajectory, kgrid=None, norigins=-1, nk=20, dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimized structure factor.</p>
<p>It uses a fortran 90 extension.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StructureFactorFast(StructureFactorLegacy):
    &#34;&#34;&#34;
    Optimized structure factor.

    It uses a fortran 90 extension.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;sk&#39;
    short_name = &#39;S(k)&#39;
    long_name = &#39;structure factor&#39;
    phasespace = [&#39;pos&#39;]

    def _compute(self):
        from atooms.trajectory.utils import is_cell_variable
        try:
            from atooms.postprocessing.fourierspace_wrap import fourierspace_module
        except ImportError:
            _log.error(&#39;f90 wrapper missing or not functioning&#39;)
            raise

        nsteps = len(self._pos_0)
        kgrid = self.kgrid

        # Setup k vectors and tabulate rho
        cnt = [0 for k in kgrid]
        rho_av = [complex(0., 0.) for k in kgrid]
        rho2_av = [complex(0., 0.) for k in kgrid]
        variable_cell = is_cell_variable(self.trajectory)
        for i in range(0, nsteps, self.skip):
            # If cell changes we have to update the wave vectors
            if variable_cell:
                self._setup(i)

            # Tabulate exponentials
            # Note: tabulating and computing takes about the same time
            if self._pos_0[i] is self._pos_1[i]:
                # Identical species
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_0
            else:
                # Cross correlation
                # TODO: cross correlation wont work
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[i])

            # for kk, knorm in enumerate(kgrid):
            #     ikvec = numpy.ndarray((3, len(selection[kk])), order=&#39;F&#39;, dtype=numpy.int32)
            #     i = 0
            #     for k in selection[kk]:
            #         ikvec[:, i] = self.kvector[knorm][k]
            #         i += 1
            for k, klist in enumerate(self._kvectors):
                # TODO: do it by transpose()
                # Fill array of kvectors in this bin
                ikvec = numpy.ndarray((3, len(klist)), order=&#39;F&#39;, dtype=numpy.int32)
                for i, kvec in enumerate(klist):
                    ikvec[:, i] = kvec
                rho = numpy.zeros(ikvec.shape[1], dtype=numpy.complex128)
                fourierspace_module.sk_bare(expo_0, ikvec, rho)
                rho_0 = rho
                rho_1 = rho
                rho2_av[k] += numpy.sum(rho_0 * rho_1.conjugate())
                cnt[k] += rho.shape[0]

        # Normalization.
        npart_0 = sum([p.shape[0] for p in self._pos_0]) / float(len(self._pos_0))
        npart_1 = sum([p.shape[0] for p in self._pos_1]) / float(len(self._pos_1))
        self.grid = kgrid
        self.value, self.value_nonorm = [], []
        for k in range(len(self.grid)):
            norm = float(npart_0 * npart_1)**0.5
            value = (rho2_av[k] / cnt[k] - rho_av[k]*rho_av[k].conjugate() / cnt[k]**2).real
            self.value.append(value / norm)
            self.value_nonorm.append(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="postprocessing.sk.StructureFactorLegacy" href="#postprocessing.sk.StructureFactorLegacy">StructureFactorLegacy</a></li>
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="postprocessing.sk.StructureFactorFast.long_name"><code class="name">var <span class="ident">long_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorFast.nbodies"><code class="name">var <span class="ident">nbodies</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorFast.phasespace"><code class="name">var <span class="ident">phasespace</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorFast.short_name"><code class="name">var <span class="ident">short_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorFast.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="postprocessing.sk.StructureFactorFast"><code class="flex name class">
<span>class <span class="ident">StructureFactorFast</span></span>
<span>(</span><span>trajectory, kgrid=None, norigins=-1, nk=20, dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimized structure factor.</p>
<p>It uses a fortran 90 extension.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StructureFactorFast(StructureFactorLegacy):
    &#34;&#34;&#34;
    Optimized structure factor.

    It uses a fortran 90 extension.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;sk&#39;
    short_name = &#39;S(k)&#39;
    long_name = &#39;structure factor&#39;
    phasespace = [&#39;pos&#39;]

    def _compute(self):
        from atooms.trajectory.utils import is_cell_variable
        try:
            from atooms.postprocessing.fourierspace_wrap import fourierspace_module
        except ImportError:
            _log.error(&#39;f90 wrapper missing or not functioning&#39;)
            raise

        nsteps = len(self._pos_0)
        kgrid = self.kgrid

        # Setup k vectors and tabulate rho
        cnt = [0 for k in kgrid]
        rho_av = [complex(0., 0.) for k in kgrid]
        rho2_av = [complex(0., 0.) for k in kgrid]
        variable_cell = is_cell_variable(self.trajectory)
        for i in range(0, nsteps, self.skip):
            # If cell changes we have to update the wave vectors
            if variable_cell:
                self._setup(i)

            # Tabulate exponentials
            # Note: tabulating and computing takes about the same time
            if self._pos_0[i] is self._pos_1[i]:
                # Identical species
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_0
            else:
                # Cross correlation
                # TODO: cross correlation wont work
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[i])

            # for kk, knorm in enumerate(kgrid):
            #     ikvec = numpy.ndarray((3, len(selection[kk])), order=&#39;F&#39;, dtype=numpy.int32)
            #     i = 0
            #     for k in selection[kk]:
            #         ikvec[:, i] = self.kvector[knorm][k]
            #         i += 1
            for k, klist in enumerate(self._kvectors):
                # TODO: do it by transpose()
                # Fill array of kvectors in this bin
                ikvec = numpy.ndarray((3, len(klist)), order=&#39;F&#39;, dtype=numpy.int32)
                for i, kvec in enumerate(klist):
                    ikvec[:, i] = kvec
                rho = numpy.zeros(ikvec.shape[1], dtype=numpy.complex128)
                fourierspace_module.sk_bare(expo_0, ikvec, rho)
                rho_0 = rho
                rho_1 = rho
                rho2_av[k] += numpy.sum(rho_0 * rho_1.conjugate())
                cnt[k] += rho.shape[0]

        # Normalization.
        npart_0 = sum([p.shape[0] for p in self._pos_0]) / float(len(self._pos_0))
        npart_1 = sum([p.shape[0] for p in self._pos_1]) / float(len(self._pos_1))
        self.grid = kgrid
        self.value, self.value_nonorm = [], []
        for k in range(len(self.grid)):
            norm = float(npart_0 * npart_1)**0.5
            value = (rho2_av[k] / cnt[k] - rho_av[k]*rho_av[k].conjugate() / cnt[k]**2).real
            self.value.append(value / norm)
            self.value_nonorm.append(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="postprocessing.sk.StructureFactorLegacy" href="#postprocessing.sk.StructureFactorLegacy">StructureFactorLegacy</a></li>
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="postprocessing.sk.StructureFactorLegacy" href="#postprocessing.sk.StructureFactorLegacy">StructureFactorLegacy</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.sk.StructureFactorLegacy.add_filter" href="correlation.html#postprocessing.correlation.Correlation.add_filter">add_filter</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.add_weight" href="correlation.html#postprocessing.correlation.Correlation.add_weight">add_weight</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.analyze" href="correlation.html#postprocessing.correlation.Correlation.analyze">analyze</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.compute" href="correlation.html#postprocessing.correlation.Correlation.compute">compute</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.do" href="correlation.html#postprocessing.correlation.Correlation.do">do</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.grid_name" href="correlation.html#postprocessing.correlation.Correlation.grid_name">grid_name</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.need_update" href="correlation.html#postprocessing.correlation.Correlation.need_update">need_update</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.read" href="correlation.html#postprocessing.correlation.Correlation.read">read</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.report" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation.report">report</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.static" href="correlation.html#postprocessing.correlation.Correlation.static">static</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.write" href="correlation.html#postprocessing.correlation.Correlation.write">write</a></code></li>
</ul>
</li>
<li><code><b><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.long_name" href="correlation.html#postprocessing.correlation.Correlation.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.nbodies" href="correlation.html#postprocessing.correlation.Correlation.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.phasespace" href="correlation.html#postprocessing.correlation.Correlation.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.short_name" href="correlation.html#postprocessing.correlation.Correlation.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.symbol" href="correlation.html#postprocessing.correlation.Correlation.symbol">symbol</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="postprocessing.sk.StructureFactorLegacy"><code class="flex name class">
<span>class <span class="ident">StructureFactor</span></span>
<span>(</span><span>trajectory, kgrid=None, norigins=-1, nk=20, dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure factor.</p>
<p>See the documentation of the <code>FourierSpaceCorrelation</code> base class
for information on the instance variables.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StructureFactorLegacy(FourierSpaceCorrelation):
    &#34;&#34;&#34;
    Structure factor.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;sk&#39;
    short_name = &#39;S(k)&#39;
    long_name = &#39;structure factor&#39;
    phasespace = [&#39;pos&#39;]

    def __init__(self, trajectory, kgrid=None, norigins=-1, nk=20,
                 dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30):
        FourierSpaceCorrelation.__init__(self, trajectory, kgrid, norigins,
                                         nk, dk, kmin, kmax, ksamples)
        self._is_cell_variable = None

    def _compute(self):
        nsteps = len(self._pos_0)
        ndims = len(self.k0)
        kgrid = self.kgrid
        
        # Setup k vectors and tabulate rho
        cnt = [0 for k in kgrid]
        rho_0_av = [complex(0., 0.) for k in kgrid]
        rho_1_av = [complex(0., 0.) for k in kgrid]
        rho2_av = [complex(0., 0.) for k in kgrid]
        variable_cell = is_cell_variable(self.trajectory)
        for i in progress(range(0, nsteps, self.skip), total=nsteps // self.skip):
            # If cell changes we have to update the wave vectors
            if variable_cell:
                self._setup(i)

            # Tabulate exponentials
            # Note: tabulating and computing takes about the same time
            if self._pos_0[i] is self._pos_1[i]:
                # Identical species
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_0
            else:
                # Cross correlation
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[i])

            # Define weights
            if self._weight is None:
                weight_0, weight_1 = 1.0, 1.0
            else:
                weight_0, weight_1 = self._weight_0[i], self._weight_1[i]

            # Nice spaghetti here
            for k, klist in enumerate(self._kvectors):
                for kvec in klist:
                    if expo_0 is expo_1:
                        # Identical species
                        if ndims == 3:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]] *
                                              expo_0[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]])
                        else:
                            tmp = weight_0 * expo_0[..., 0, kvec[0]]
                            for idim in range(1, ndims):
                                tmp *= expo_0[..., idim, kvec[idim]]
                            rho_0 = numpy.sum(tmp)

                        rho_1 = rho_0
                    else:
                        # Cross correlation
                        if ndims == 3:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]] *
                                              expo_0[..., 2, kvec[2]])
                            rho_1 = numpy.sum(weight_1 *
                                              expo_1[..., 0, kvec[0]] *
                                              expo_1[..., 1, kvec[1]] *
                                              expo_1[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]])
                            rho_1 = numpy.sum(weight_1 *
                                              expo_1[..., 0, kvec[0]] *
                                              expo_1[..., 1, kvec[1]])
                        else:
                            tmp = weight_0 * expo_0[..., 0, kvec[0]]
                            for idim in range(ndims):
                                tmp *= expo_0[..., idim, kvec[idim]]
                            rho_0 = numpy.sum(tmp)
                            tmp = weight_0 * expo_1[..., 0, kvec[0]]
                            for idim in range(ndims):
                                tmp *= expo_1[..., idim, kvec[idim]]
                            rho_1 = numpy.sum(tmp)

                    # Cumulate averages
                    rho_0_av[k] += rho_0
                    rho_1_av[k] += rho_1
                    rho2_av[k] += (rho_0 * rho_1.conjugate())
                    cnt[k] += 1

        # In the absence of a microscopic field, the average density is zero.
        # We get rid of the average and compute &lt;rho(k)rho*(k)&gt;.
        if self._weight_0 is None:
            rho_0_av = [complex(0., 0.) for k in kgrid]
            rho_1_av = [complex(0., 0.) for k in kgrid]

        # Normalization
        npart_0 = sum([p.shape[0] for p in self._pos_0]) / float(len(self._pos_0))
        npart_1 = sum([p.shape[0] for p in self._pos_1]) / float(len(self._pos_1))
        self.grid = kgrid
        self.value, self.value_nonorm = [], []
        for k in range(len(self.grid)):
            norm = float(npart_0 * npart_1)**0.5
            value = (rho2_av[k] / cnt[k] - rho_0_av[k] * rho_1_av[k].conjugate() / cnt[k]**2).real
            self.value.append(value / norm)
            self.value_nonorm.append(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="postprocessing.sk.StructureFactorFast" href="#postprocessing.sk.StructureFactorFast">StructureFactorFast</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="postprocessing.sk.StructureFactorLegacy.long_name"><code class="name">var <span class="ident">long_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorLegacy.nbodies"><code class="name">var <span class="ident">nbodies</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorLegacy.phasespace"><code class="name">var <span class="ident">phasespace</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorLegacy.short_name"><code class="name">var <span class="ident">short_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="postprocessing.sk.StructureFactorLegacy.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="postprocessing.sk.StructureFactorLegacy"><code class="flex name class">
<span>class <span class="ident">StructureFactorLegacy</span></span>
<span>(</span><span>trajectory, kgrid=None, norigins=-1, nk=20, dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure factor.</p>
<p>See the documentation of the <code>FourierSpaceCorrelation</code> base class
for information on the instance variables.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StructureFactorLegacy(FourierSpaceCorrelation):
    &#34;&#34;&#34;
    Structure factor.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;sk&#39;
    short_name = &#39;S(k)&#39;
    long_name = &#39;structure factor&#39;
    phasespace = [&#39;pos&#39;]

    def __init__(self, trajectory, kgrid=None, norigins=-1, nk=20,
                 dk=0.1, kmin=-1.0, kmax=15.0, ksamples=30):
        FourierSpaceCorrelation.__init__(self, trajectory, kgrid, norigins,
                                         nk, dk, kmin, kmax, ksamples)
        self._is_cell_variable = None

    def _compute(self):
        nsteps = len(self._pos_0)
        ndims = len(self.k0)
        kgrid = self.kgrid
        
        # Setup k vectors and tabulate rho
        cnt = [0 for k in kgrid]
        rho_0_av = [complex(0., 0.) for k in kgrid]
        rho_1_av = [complex(0., 0.) for k in kgrid]
        rho2_av = [complex(0., 0.) for k in kgrid]
        variable_cell = is_cell_variable(self.trajectory)
        for i in progress(range(0, nsteps, self.skip), total=nsteps // self.skip):
            # If cell changes we have to update the wave vectors
            if variable_cell:
                self._setup(i)

            # Tabulate exponentials
            # Note: tabulating and computing takes about the same time
            if self._pos_0[i] is self._pos_1[i]:
                # Identical species
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_0
            else:
                # Cross correlation
                expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[i])
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[i])

            # Define weights
            if self._weight is None:
                weight_0, weight_1 = 1.0, 1.0
            else:
                weight_0, weight_1 = self._weight_0[i], self._weight_1[i]

            # Nice spaghetti here
            for k, klist in enumerate(self._kvectors):
                for kvec in klist:
                    if expo_0 is expo_1:
                        # Identical species
                        if ndims == 3:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]] *
                                              expo_0[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]])
                        else:
                            tmp = weight_0 * expo_0[..., 0, kvec[0]]
                            for idim in range(1, ndims):
                                tmp *= expo_0[..., idim, kvec[idim]]
                            rho_0 = numpy.sum(tmp)

                        rho_1 = rho_0
                    else:
                        # Cross correlation
                        if ndims == 3:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]] *
                                              expo_0[..., 2, kvec[2]])
                            rho_1 = numpy.sum(weight_1 *
                                              expo_1[..., 0, kvec[0]] *
                                              expo_1[..., 1, kvec[1]] *
                                              expo_1[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_0 = numpy.sum(weight_0 *
                                              expo_0[..., 0, kvec[0]] *
                                              expo_0[..., 1, kvec[1]])
                            rho_1 = numpy.sum(weight_1 *
                                              expo_1[..., 0, kvec[0]] *
                                              expo_1[..., 1, kvec[1]])
                        else:
                            tmp = weight_0 * expo_0[..., 0, kvec[0]]
                            for idim in range(ndims):
                                tmp *= expo_0[..., idim, kvec[idim]]
                            rho_0 = numpy.sum(tmp)
                            tmp = weight_0 * expo_1[..., 0, kvec[0]]
                            for idim in range(ndims):
                                tmp *= expo_1[..., idim, kvec[idim]]
                            rho_1 = numpy.sum(tmp)

                    # Cumulate averages
                    rho_0_av[k] += rho_0
                    rho_1_av[k] += rho_1
                    rho2_av[k] += (rho_0 * rho_1.conjugate())
                    cnt[k] += 1

        # In the absence of a microscopic field, the average density is zero.
        # We get rid of the average and compute &lt;rho(k)rho*(k)&gt;.
        if self._weight_0 is None:
            rho_0_av = [complex(0., 0.) for k in kgrid]
            rho_1_av = [complex(0., 0.) for k in kgrid]

        # Normalization
        npart_0 = sum([p.shape[0] for p in self._pos_0]) / float(len(self._pos_0))
        npart_1 = sum([p.shape[0] for p in self._pos_1]) / float(len(self._pos_1))
        self.grid = kgrid
        self.value, self.value_nonorm = [], []
        for k in range(len(self.grid)):
            norm = float(npart_0 * npart_1)**0.5
            value = (rho2_av[k] / cnt[k] - rho_0_av[k] * rho_1_av[k].conjugate() / cnt[k]**2).real
            self.value.append(value / norm)
            self.value_nonorm.append(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="postprocessing.sk.StructureFactorFast" href="#postprocessing.sk.StructureFactorFast">StructureFactorFast</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.add_filter" href="correlation.html#postprocessing.correlation.Correlation.add_filter">add_filter</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.add_weight" href="correlation.html#postprocessing.correlation.Correlation.add_weight">add_weight</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.analyze" href="correlation.html#postprocessing.correlation.Correlation.analyze">analyze</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.compute" href="correlation.html#postprocessing.correlation.Correlation.compute">compute</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.do" href="correlation.html#postprocessing.correlation.Correlation.do">do</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.grid_name" href="correlation.html#postprocessing.correlation.Correlation.grid_name">grid_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.long_name" href="correlation.html#postprocessing.correlation.Correlation.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.nbodies" href="correlation.html#postprocessing.correlation.Correlation.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.need_update" href="correlation.html#postprocessing.correlation.Correlation.need_update">need_update</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.phasespace" href="correlation.html#postprocessing.correlation.Correlation.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.read" href="correlation.html#postprocessing.correlation.Correlation.read">read</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.report" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation.report">report</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.short_name" href="correlation.html#postprocessing.correlation.Correlation.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.static" href="correlation.html#postprocessing.correlation.Correlation.static">static</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.symbol" href="correlation.html#postprocessing.correlation.Correlation.symbol">symbol</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.write" href="correlation.html#postprocessing.correlation.Correlation.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="postprocessing" href="index.html">postprocessing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="postprocessing.sk.StructureFactorFast" href="#postprocessing.sk.StructureFactorFast">StructureFactorFast</a></code></h4>
<ul class="">
<li><code><a title="postprocessing.sk.StructureFactorFast.long_name" href="#postprocessing.sk.StructureFactorFast.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorFast.nbodies" href="#postprocessing.sk.StructureFactorFast.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorFast.phasespace" href="#postprocessing.sk.StructureFactorFast.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorFast.short_name" href="#postprocessing.sk.StructureFactorFast.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorFast.symbol" href="#postprocessing.sk.StructureFactorFast.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="postprocessing.sk.StructureFactorFast" href="#postprocessing.sk.StructureFactorFast">StructureFactorFast</a></code></h4>
</li>
<li>
<h4><code><a title="postprocessing.sk.StructureFactorLegacy" href="#postprocessing.sk.StructureFactorLegacy">StructureFactorLegacy</a></code></h4>
<ul class="">
<li><code><a title="postprocessing.sk.StructureFactorLegacy.long_name" href="#postprocessing.sk.StructureFactorLegacy.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.nbodies" href="#postprocessing.sk.StructureFactorLegacy.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.phasespace" href="#postprocessing.sk.StructureFactorLegacy.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.short_name" href="#postprocessing.sk.StructureFactorLegacy.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.sk.StructureFactorLegacy.symbol" href="#postprocessing.sk.StructureFactorLegacy.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="postprocessing.sk.StructureFactorLegacy" href="#postprocessing.sk.StructureFactorLegacy">StructureFactorLegacy</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>