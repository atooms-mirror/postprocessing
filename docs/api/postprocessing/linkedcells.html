<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>postprocessing.linkedcells API documentation</title>
<meta name="description" content="Linked cells to compute neighbors efficiently." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>postprocessing.linkedcells</code></h1>
</header>
<section id="section-intro">
<p>Linked cells to compute neighbors efficiently.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of atooms
# Copyright 2010-2014, Daniele Coslovich

&#34;&#34;&#34;Linked cells to compute neighbors efficiently.&#34;&#34;&#34;

from collections import defaultdict
import numpy

# TODO: define iterator over cells

class LinkedCells(object):

    def __init__(self, rcut):
        self.rcut = rcut
        self.neighbors = []
        self._is_adjusted = False

    def adjust(self, box, newton, periodic=None):
        self.box = box
        self.hbox = box / 2
        self.n_cell = (box / self.rcut).astype(int)
        self.box_cell = self.box / self.n_cell
        if periodic is None:
            periodic = numpy.array([True] * len(box))
        self._map(newton, periodic)

    def _map(self, newton, periodic):
        def _pbc(t, N):
            &#34;&#34;&#34;Apply PBCs to cell only along periodic directions&#34;&#34;&#34;
            for i in range(len(t)):
                if not periodic[i]:
                    continue
                if t[i] &gt;= N[i]:
                    t[i] -= N[i]
                elif t[i] &lt; 0:
                    t[i] += N[i]
            return t

        def _outside(t, N):
            &#34;&#34;&#34;Check whether subcell is outside cell&#34;&#34;&#34;
            for i in range(len(t)):
                if t[i] &gt;= N[i] or t[i] &lt; 0:
                    return True
            return False

        def _map_3d_newton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    for iz in range(n_cell[2]):
                        # This is a map of neighbouring cells obeying III law
                        neigh_cell[(ix, iy, iz)] = \
                            [(ix+1, iy, iz), (ix+1, iy+1, iz), (ix, iy+1, iz),
                             (ix-1, iy+1, iz), (ix+1, iy, iz-1), (ix+1, iy+1, iz-1),
                             (ix, iy+1, iz-1), (ix-1, iy+1, iz-1), (ix+1, iy, iz+1),
                             (ix+1, iy+1, iz+1), (ix, iy+1, iz+1), (ix-1, iy+1, iz+1),
                             (ix, iy, iz+1)]
            return neigh_cell

        def _map_2d_newton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    # This is a map of neighbouring cells obeying III law
                    neigh_cell[(ix, iy)] = \
                        [(ix+1, iy), (ix+1, iy+1), (ix, iy+1), (ix-1, iy+1)]
            return neigh_cell

        def _map_3d_nonewton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    for iz in range(n_cell[2]):
                        neigh_cell[(ix, iy, iz)] = []
                        for deltax in [-1, 0, 1]:
                            for deltay in [-1, 0, 1]:
                                for deltaz in [-1, 0, 1]:
                                    if deltax == deltay == deltaz == 0:
                                        continue
                                    neigh_cell[(ix, iy, iz)].append((ix+deltax, iy+deltay, iz+deltaz))
            return neigh_cell

        def _map_2d_nonewton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    neigh_cell[(ix, iy)] = []
                    for deltax in [-1, 0, 1]:
                        for deltay in [-1, 0, 1]:
                            if deltax == deltay == 0:
                                continue
                            neigh_cell[(ix, iy)].append((ix+deltax, iy+deltay))
            return neigh_cell

        if len(self.n_cell) == 3:
            if newton:
                self._neigh_cell = _map_3d_newton(self.n_cell)
            else:
                self._neigh_cell = _map_3d_nonewton(self.n_cell)
        elif len(self.n_cell) == 2:
            if newton:
                self._neigh_cell = _map_2d_newton(self.n_cell)
            else:
                self._neigh_cell = _map_2d_nonewton(self.n_cell)
        else:
            raise ValueError(&#39;linked cells not supported for dimensions not in {2,3}&#39;)

        # Apply PBC
        for key in self._neigh_cell:
            for idx in range(len(self._neigh_cell[key])):
                folded = _pbc(list(self._neigh_cell[key][idx]), self.n_cell)
                self._neigh_cell[key][idx] = tuple(folded)

        # Remove subcells that are out of bounds
        # (this is only applied to non periodic directions)
        new_neigh_cell = {}
        for key in self._neigh_cell:
            new_neigh_cell[key] = []
            for subcell in self._neigh_cell[key]:
                if not _outside(subcell, self.n_cell):
                    new_neigh_cell[key].append(subcell)
        self._neigh_cell = new_neigh_cell

    def _index(self, pos):
        x = ((pos + self.hbox) / self.box_cell)
        return x.astype(numpy.int)

    def on_border(self, pos):
        index = list(self._index(pos))
        found = False
        for i in range(len(index)):
            if index[i] == self.n_cell[i] - 1 or index[i] == 0:
                found = True
                break
        return found

    def compute(self, box, pos, other=None, as_array=False, newton=True, periodic=None):
        if not self._is_adjusted:
            self.adjust(box, newton=other is None and newton, periodic=periodic)
            self._is_adjusted = True
        # We only need positions here but how can we be sure that
        # this is the same set of particles we use when retrieving
        # the neighbours? We should keep a reference.
        # from atooms.postprocessing.realspace_wrap import compute
        # index = numpy.ndarray(pos.shape, dtype=numpy.int)
        # compute.bin_in_cell(pos, self.hbox, self.box_cell, index)

        self.neighbors = []
        self.number_of_neighbors = []
        index = self._index(pos)
        if other is None:
            index_other = index
        else:
            index_other = self._index(other)

        particle_in_cell = defaultdict(list)
        for ipart, icell in enumerate(index_other):
            particle_in_cell[tuple(icell)].append(ipart)

        for ipart in range(pos.shape[0]):
            icell = tuple(index[ipart])
            # Initialize an empty list
            neighbors = []
            # Start with particles in the cell of particle ipart
            if other is None:
                neighbors += [_ for _ in particle_in_cell[icell] if _ &gt; ipart]
            else:
                neighbors += particle_in_cell[icell]
                # try:
                #     neighbors.remove(ipart)
                # except:
                #     pass
            # Loop over neighbors cells and add neighbors
            for jcell in self._neigh_cell[icell]:
                neighbors += particle_in_cell[jcell]
            self.neighbors.append(neighbors)
            self.number_of_neighbors.append(len(neighbors))

        if as_array:
            npart = len(self.neighbors)
            number_of_neighbors = numpy.array(self.number_of_neighbors)
            neighbors_array = numpy.ndarray((npart, max(number_of_neighbors)), dtype=numpy.int)
            for ipart in range(len(self.neighbors)):
                neighbors_array[ipart, 0:len(self.neighbors[ipart])] = self.neighbors[ipart]
            self.neighbors = neighbors_array
            self.number_of_neighbors = number_of_neighbors
            return self.neighbors, number_of_neighbors
        else:
            return self.neighbors

# import sys
# from atooms.system import Particle
# import atooms.trajectory as trj
# t = trj.Trajectory(sys.argv[1])
# system = t[0]
# # system.particle = []
# # dr = system.cell.side[0] / 20
# # for ix in range(0,20):
# #     for iy in range(0,20):
# #         system.particle.append(Particle(position=[ix*dr+dr/2 - system.cell.side[0]/2, iy*dr+dr/2 - system.cell.side[0]/2, 0]))

# trj.decorators.change_species(system, &#39;F&#39;)
# print(&#39;----&#39;)
# pos = system.dump(&#39;pos&#39;, order=&#39;C&#39;)
# ids = system.dump(&#39;spe&#39;)
# print(&#39;----&#39;)
# lc = _LinkedCells(rcut=2.0)
# nn, num = lc.compute(system.cell.side, pos, as_array=True)
# print(nn[0][0:num[0]])
# print(&#39;#&#39;, lc.box_cell / (system.cell.side/2))
# print(&#39;----&#39;)

# for j in nn[0][0:num[0]]:
#     dr = system.particle[0].distance(system.particle[j], system.cell)
#     print(numpy.sum(dr**2)**0.5, lc.box_cell[0] * 2)

# # from atooms.postprocessing.realspace_wrap import compute
# # rcut = numpy.array([[1.5, 1.5], [1.5, 1.5]])
# # rcut[:] = lc.box_cell[0] * 2
# # max_neighbors = 300
# # number_of_neighbors = numpy.ndarray(pos.shape[0], dtype=numpy.int32)
# # neighbors = numpy.ndarray((pos.shape[0], max_neighbors), dtype=numpy.int32, order=&#39;F&#39;)
# # #print(pos.shape)
# # pos = numpy.array(pos, order=&#39;F&#39;)
# # compute.neighbors_list(&#39;C&#39;,system.cell.side,pos.transpose(),ids,rcut,number_of_neighbors,neighbors)
# # #neighbors_0 = numpy.ndarray(max_neighbors, dtype=numpy.int32, order=&#39;F&#39;)
# # #nn = numpy.array(0, dtype=numpy.int32)
# # # compute.neighbors(&#39;C&#39;,system.cell.side,pos,pos[0],ids,rcut,nn,neighbors_0)
# # # print(neighbors[0][0:number_of_neighbors[0]])


# # print(str(system.particle[0].position / (system.cell.side/2))[1:-1])
# # print()
# # print()
# # for nnn in [sorted(neighbors[0]), sorted(lc.neighbors[0])]:
# #     for j in nnn:
# #         print(str(system.particle[j].position / (system.cell.side/2))[1:-1])
# #     print()
# #     print()


# # js = []
# # for j in range(pos.shape[0]):
# #     dr = system.particle[0].distance(system.particle[j], system.cell)
# #     if j&gt; 0 and numpy.sum(dr**2)**0.5 &lt; lc.box_cell[0] * 2:
# #         js.append(j)

# # # print(len(sorted(lc.neighbors[0])))
# # # print(len(sorted(neighbors[0][0:number_of_neighbors[0]])))
# # # print(len(sorted(js)))
# # # print(&#39;----&#39;)

# # # for nnn in [sorted(lc.neighbors[0]),
# # #             sorted(neighbors[0][0:number_of_neighbors[0]])]:
# # #     for j in nnn:
# # #         print(str(system.particle[j].position)[1:-1])
# # #     print()
# # #     print()

# # # for nnn in [sorted(js),
# # #             sorted(neighbors[0][0:number_of_neighbors[0]])]:
# # #     for j in nnn:
# # #         dr = system.particle[0].distance(system.particle[j], system.cell)
# # #         print(j, numpy.sum(dr**2)**0.5)
# # #     print


# # # # for x in neighbors:
# # # #     print(x)
# # # for i in range(pos.shape[0]):
# # #     x = list(sorted(lc.neighbors[i]))
# # #     y = neighbors[i][0:number_of_neighbors[i]]
# # #     print(x)
# # #     print(y)
# # #     assert numpy.all(x == y)
# # #     print()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="postprocessing.linkedcells.LinkedCells"><code class="flex name class">
<span>class <span class="ident">LinkedCells</span></span>
<span>(</span><span>rcut)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkedCells(object):

    def __init__(self, rcut):
        self.rcut = rcut
        self.neighbors = []
        self._is_adjusted = False

    def adjust(self, box, newton, periodic=None):
        self.box = box
        self.hbox = box / 2
        self.n_cell = (box / self.rcut).astype(int)
        self.box_cell = self.box / self.n_cell
        if periodic is None:
            periodic = numpy.array([True] * len(box))
        self._map(newton, periodic)

    def _map(self, newton, periodic):
        def _pbc(t, N):
            &#34;&#34;&#34;Apply PBCs to cell only along periodic directions&#34;&#34;&#34;
            for i in range(len(t)):
                if not periodic[i]:
                    continue
                if t[i] &gt;= N[i]:
                    t[i] -= N[i]
                elif t[i] &lt; 0:
                    t[i] += N[i]
            return t

        def _outside(t, N):
            &#34;&#34;&#34;Check whether subcell is outside cell&#34;&#34;&#34;
            for i in range(len(t)):
                if t[i] &gt;= N[i] or t[i] &lt; 0:
                    return True
            return False

        def _map_3d_newton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    for iz in range(n_cell[2]):
                        # This is a map of neighbouring cells obeying III law
                        neigh_cell[(ix, iy, iz)] = \
                            [(ix+1, iy, iz), (ix+1, iy+1, iz), (ix, iy+1, iz),
                             (ix-1, iy+1, iz), (ix+1, iy, iz-1), (ix+1, iy+1, iz-1),
                             (ix, iy+1, iz-1), (ix-1, iy+1, iz-1), (ix+1, iy, iz+1),
                             (ix+1, iy+1, iz+1), (ix, iy+1, iz+1), (ix-1, iy+1, iz+1),
                             (ix, iy, iz+1)]
            return neigh_cell

        def _map_2d_newton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    # This is a map of neighbouring cells obeying III law
                    neigh_cell[(ix, iy)] = \
                        [(ix+1, iy), (ix+1, iy+1), (ix, iy+1), (ix-1, iy+1)]
            return neigh_cell

        def _map_3d_nonewton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    for iz in range(n_cell[2]):
                        neigh_cell[(ix, iy, iz)] = []
                        for deltax in [-1, 0, 1]:
                            for deltay in [-1, 0, 1]:
                                for deltaz in [-1, 0, 1]:
                                    if deltax == deltay == deltaz == 0:
                                        continue
                                    neigh_cell[(ix, iy, iz)].append((ix+deltax, iy+deltay, iz+deltaz))
            return neigh_cell

        def _map_2d_nonewton(n_cell):
            neigh_cell = {}
            for ix in range(n_cell[0]):
                for iy in range(n_cell[1]):
                    neigh_cell[(ix, iy)] = []
                    for deltax in [-1, 0, 1]:
                        for deltay in [-1, 0, 1]:
                            if deltax == deltay == 0:
                                continue
                            neigh_cell[(ix, iy)].append((ix+deltax, iy+deltay))
            return neigh_cell

        if len(self.n_cell) == 3:
            if newton:
                self._neigh_cell = _map_3d_newton(self.n_cell)
            else:
                self._neigh_cell = _map_3d_nonewton(self.n_cell)
        elif len(self.n_cell) == 2:
            if newton:
                self._neigh_cell = _map_2d_newton(self.n_cell)
            else:
                self._neigh_cell = _map_2d_nonewton(self.n_cell)
        else:
            raise ValueError(&#39;linked cells not supported for dimensions not in {2,3}&#39;)

        # Apply PBC
        for key in self._neigh_cell:
            for idx in range(len(self._neigh_cell[key])):
                folded = _pbc(list(self._neigh_cell[key][idx]), self.n_cell)
                self._neigh_cell[key][idx] = tuple(folded)

        # Remove subcells that are out of bounds
        # (this is only applied to non periodic directions)
        new_neigh_cell = {}
        for key in self._neigh_cell:
            new_neigh_cell[key] = []
            for subcell in self._neigh_cell[key]:
                if not _outside(subcell, self.n_cell):
                    new_neigh_cell[key].append(subcell)
        self._neigh_cell = new_neigh_cell

    def _index(self, pos):
        x = ((pos + self.hbox) / self.box_cell)
        return x.astype(numpy.int)

    def on_border(self, pos):
        index = list(self._index(pos))
        found = False
        for i in range(len(index)):
            if index[i] == self.n_cell[i] - 1 or index[i] == 0:
                found = True
                break
        return found

    def compute(self, box, pos, other=None, as_array=False, newton=True, periodic=None):
        if not self._is_adjusted:
            self.adjust(box, newton=other is None and newton, periodic=periodic)
            self._is_adjusted = True
        # We only need positions here but how can we be sure that
        # this is the same set of particles we use when retrieving
        # the neighbours? We should keep a reference.
        # from atooms.postprocessing.realspace_wrap import compute
        # index = numpy.ndarray(pos.shape, dtype=numpy.int)
        # compute.bin_in_cell(pos, self.hbox, self.box_cell, index)

        self.neighbors = []
        self.number_of_neighbors = []
        index = self._index(pos)
        if other is None:
            index_other = index
        else:
            index_other = self._index(other)

        particle_in_cell = defaultdict(list)
        for ipart, icell in enumerate(index_other):
            particle_in_cell[tuple(icell)].append(ipart)

        for ipart in range(pos.shape[0]):
            icell = tuple(index[ipart])
            # Initialize an empty list
            neighbors = []
            # Start with particles in the cell of particle ipart
            if other is None:
                neighbors += [_ for _ in particle_in_cell[icell] if _ &gt; ipart]
            else:
                neighbors += particle_in_cell[icell]
                # try:
                #     neighbors.remove(ipart)
                # except:
                #     pass
            # Loop over neighbors cells and add neighbors
            for jcell in self._neigh_cell[icell]:
                neighbors += particle_in_cell[jcell]
            self.neighbors.append(neighbors)
            self.number_of_neighbors.append(len(neighbors))

        if as_array:
            npart = len(self.neighbors)
            number_of_neighbors = numpy.array(self.number_of_neighbors)
            neighbors_array = numpy.ndarray((npart, max(number_of_neighbors)), dtype=numpy.int)
            for ipart in range(len(self.neighbors)):
                neighbors_array[ipart, 0:len(self.neighbors[ipart])] = self.neighbors[ipart]
            self.neighbors = neighbors_array
            self.number_of_neighbors = number_of_neighbors
            return self.neighbors, number_of_neighbors
        else:
            return self.neighbors</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="postprocessing.linkedcells.LinkedCells.adjust"><code class="name flex">
<span>def <span class="ident">adjust</span></span>(<span>self, box, newton, periodic=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust(self, box, newton, periodic=None):
    self.box = box
    self.hbox = box / 2
    self.n_cell = (box / self.rcut).astype(int)
    self.box_cell = self.box / self.n_cell
    if periodic is None:
        periodic = numpy.array([True] * len(box))
    self._map(newton, periodic)</code></pre>
</details>
</dd>
<dt id="postprocessing.linkedcells.LinkedCells.compute"><code class="name flex">
<span>def <span class="ident">compute</span></span>(<span>self, box, pos, other=None, as_array=False, newton=True, periodic=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute(self, box, pos, other=None, as_array=False, newton=True, periodic=None):
    if not self._is_adjusted:
        self.adjust(box, newton=other is None and newton, periodic=periodic)
        self._is_adjusted = True
    # We only need positions here but how can we be sure that
    # this is the same set of particles we use when retrieving
    # the neighbours? We should keep a reference.
    # from atooms.postprocessing.realspace_wrap import compute
    # index = numpy.ndarray(pos.shape, dtype=numpy.int)
    # compute.bin_in_cell(pos, self.hbox, self.box_cell, index)

    self.neighbors = []
    self.number_of_neighbors = []
    index = self._index(pos)
    if other is None:
        index_other = index
    else:
        index_other = self._index(other)

    particle_in_cell = defaultdict(list)
    for ipart, icell in enumerate(index_other):
        particle_in_cell[tuple(icell)].append(ipart)

    for ipart in range(pos.shape[0]):
        icell = tuple(index[ipart])
        # Initialize an empty list
        neighbors = []
        # Start with particles in the cell of particle ipart
        if other is None:
            neighbors += [_ for _ in particle_in_cell[icell] if _ &gt; ipart]
        else:
            neighbors += particle_in_cell[icell]
            # try:
            #     neighbors.remove(ipart)
            # except:
            #     pass
        # Loop over neighbors cells and add neighbors
        for jcell in self._neigh_cell[icell]:
            neighbors += particle_in_cell[jcell]
        self.neighbors.append(neighbors)
        self.number_of_neighbors.append(len(neighbors))

    if as_array:
        npart = len(self.neighbors)
        number_of_neighbors = numpy.array(self.number_of_neighbors)
        neighbors_array = numpy.ndarray((npart, max(number_of_neighbors)), dtype=numpy.int)
        for ipart in range(len(self.neighbors)):
            neighbors_array[ipart, 0:len(self.neighbors[ipart])] = self.neighbors[ipart]
        self.neighbors = neighbors_array
        self.number_of_neighbors = number_of_neighbors
        return self.neighbors, number_of_neighbors
    else:
        return self.neighbors</code></pre>
</details>
</dd>
<dt id="postprocessing.linkedcells.LinkedCells.on_border"><code class="name flex">
<span>def <span class="ident">on_border</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_border(self, pos):
    index = list(self._index(pos))
    found = False
    for i in range(len(index)):
        if index[i] == self.n_cell[i] - 1 or index[i] == 0:
            found = True
            break
    return found</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="postprocessing" href="index.html">postprocessing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="postprocessing.linkedcells.LinkedCells" href="#postprocessing.linkedcells.LinkedCells">LinkedCells</a></code></h4>
<ul class="">
<li><code><a title="postprocessing.linkedcells.LinkedCells.adjust" href="#postprocessing.linkedcells.LinkedCells.adjust">adjust</a></code></li>
<li><code><a title="postprocessing.linkedcells.LinkedCells.compute" href="#postprocessing.linkedcells.LinkedCells.compute">compute</a></code></li>
<li><code><a title="postprocessing.linkedcells.LinkedCells.on_border" href="#postprocessing.linkedcells.LinkedCells.on_border">on_border</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>