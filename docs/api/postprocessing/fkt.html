<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>postprocessing.fkt API documentation</title>
<meta name="description" content="Intermediate scattering function." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>postprocessing.fkt</code></h1>
</header>
<section id="section-intro">
<p>Intermediate scattering function.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of atooms
# Copyright 2010-2018, Daniele Coslovich

&#34;&#34;&#34;Intermediate scattering function.&#34;&#34;&#34;

import logging
from collections import defaultdict

import numpy
from atooms.trajectory.utils import check_block_size

from . import core
from atooms.trajectory import Trajectory
from .helpers import logx_grid, setup_t_grid
from .correlation import Correlation
from .fourierspace import FourierSpaceCorrelation, expo_sphere
from .progress import progress

__all__ = [&#39;SelfIntermediateScattering&#39;,
           &#39;SelfIntermediateScatteringLegacy&#39;, &#39;SelfIntermediateScatteringFast&#39;,
           &#39;IntermediateScattering&#39;]

_log = logging.getLogger(__name__)


def _write_tau(out, db):
    # Custom writing of relaxation times
    out.write(&#39;# title: relaxation times tau(k) as a function of k\n&#39;)
    out.write(&#39;# columns: k, tau(k)\n&#39;)
    out.write(&#39;# note: tau is the time at which the correlation function has decayed to 1/e\n&#39;)
    for k, tau in db[&#39;relaxation times tau&#39;].items():
        if tau is None:
            out.write(&#39;%g\n&#39; % k)
        else:
            out.write(&#39;%g %g\n&#39; % (k, tau))

def _extract_tau(k, t, f, factor=1/numpy.exp(1.0)):
    from .helpers import feqc
    # Ensure first point in time grid is t=0
    # This will be enforced by the classes below but we never know
    if t[0] &gt; 0:
        raise ValueError(&#39;First point in time grid must be zero&#39;)
    tau = {}
    for i, k in enumerate(k):
        try:
            tau[k] = feqc(t, f[i], f[i][0]*factor)[0]
        except ValueError:
            tau[k] = None
    return tau


class IntermediateScatteringBase(FourierSpaceCorrelation):

    def __init__(self, trajectory, kgrid=None, tgrid=None, nk=1,
                 tsamples=1, dk=0.1, kmin=1.0, kmax=10.0, ksamples=10,
                 norigins=-1, fix_cm=False, normalize=True):
        FourierSpaceCorrelation.__init__(self, trajectory, [kgrid, tgrid], norigins,
                                         nk, dk, kmin, kmax, ksamples, fix_cm, normalize)
        # Before setting up the time grid, we need to check periodicity over blocks
        try:
            check_block_size(self.trajectory.steps, self.trajectory.block_size)
        except IndexError as e:
            _log.warn(&#39;issue with trajectory blocks, the time grid may not correspond to the requested one ({})&#39;, e)

        # Setup time grid
        # The default time grid is the same for F_s(k,t) and F(k,t)
        if self.grid[1] is None:
            self.grid[1] = logx_grid(0.0, self.trajectory.total_time * 0.75, tsamples)
        else:
            # If the values are normalized, we make sure the
            # user-provided time grid includes t=0. It is removed
            # after normalization
            if self.normalize:
                if self.grid[1][0] &gt; 0:
                    _log.info(&#39;adding t=0 to the time grid to normalize F_s(k,t)&#39;)
                    self.grid[1] = [0.0] + list(self.grid[1])

        # When a single time origin is requested,
        # make sure no additional time origins except the first frame is used
        self._discrete_tgrid = setup_t_grid(self.trajectory, self.grid[1], offset=norigins != &#39;1&#39; and norigins != 1)


class SelfIntermediateScatteringLegacy(IntermediateScatteringBase):
    &#34;&#34;&#34;
    Self part of the intermediate scattering function.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    symbol = &#39;fskt&#39;
    short_name = &#39;F_s(k,t)&#39;
    long_name = &#39;self intermediate scattering function&#39;
    phasespace = &#39;pos&#39;

    def __init__(self, trajectory, kgrid=None, tgrid=None, nk=8,
                 tsamples=60, dk=0.1, kmin=1.0, kmax=10.0,
                 ksamples=10, norigins=-1, fix_cm=False,
                 lookup_mb=64.0, normalize=True):
        super(SelfIntermediateScatteringLegacy,
              self).__init__(trajectory, kgrid=kgrid, tgrid=tgrid,
                             nk=nk, tsamples=tsamples, dk=dk, kmin=kmin,
                             kmax=kmax, ksamples=ksamples, norigins=norigins,
                             fix_cm=fix_cm, normalize=normalize)
        self.lookup_mb = lookup_mb
        &#34;&#34;&#34;Memory in Mb allocated for exponentials tabulation&#34;&#34;&#34;

    def _compute(self):
        # Shortcuts
        pos = numpy.array(self._pos)
        ndims = len(self.k0)
        skip = self.skip
        # To optimize without wasting too much memory (we have
        # troubles here) we group particles in blocks and tabulate the
        # exponentials over time. This is more memory consuming but we
        # can optimize the inner loop. Even better, we could change
        # the order in the tabulated expo array to speed things up
        # Use 10 blocks, but do not exceed 200 particles
        number_of_blocks = 10
        block = int(pos[0].shape[0] / float(number_of_blocks))
        block = max(20, block)
        block = min(200, block)

        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        origins = range(0, pos.shape[1], block)
        for j in progress(origins):
            # Tabulate exponentials
            x = expo_sphere(self.k0, self._koffset, pos[:, j:j + block, :])
            for ik, klist in enumerate(self._kvectors):
                for kvec in klist:
                    for off, i in self._discrete_tgrid:
                        for i0 in range(off, x.shape[0]-i, skip):
                            # Get the actual time difference. steps must be accessed efficiently (cached!)
                            dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                            # Dimensional switch
                            if ndims == 3:
                                acf[ik][dt] += numpy.sum(x[i0+i, :, 0, kvec[0]]*x[i0, :, 0, kvec[0]].conjugate() *
                                                         x[i0+i, :, 1, kvec[1]]*x[i0, :, 1, kvec[1]].conjugate() *
                                                         x[i0+i, :, 2, kvec[2]]*x[i0, :, 2, kvec[2]].conjugate()).real
                            elif ndims == 2:
                                acf[ik][dt] += numpy.sum(x[i0+i, :, 0, kvec[0]]*x[i0, :, 0, kvec[0]].conjugate() *
                                                         x[i0+i, :, 1, kvec[1]]*x[i0, :, 1, kvec[1]].conjugate()).real

                            else:
                                # Arbitrary dimension (a bit slower)
                                tmp = x[i0+i, :, 0, kvec[0]]*x[i0, :, 0, kvec[0]].conjugate()
                                for idim in range(1, len(kvec)):
                                    tmp *= x[i0+i, :, idim, kvec[idim]]*x[i0, :, idim, kvec[idim]].conjugate()
                                acf[ik][dt] += numpy.sum(tmp).real
                            cnt[ik][dt] += x.shape[1]

        # Define grids
        tgrid = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in tgrid]
        self.value = [[acf[k][t] / cnt[k][t] for t in tgrid] for k in range(len(acf))]

        # Normalization
        if self.normalize:
            for k in range(len(self.grid[0])):
                for i in range(len(self.value[k])):
                    self.value[k][i] /= self.value[k][0]

    def analyze(self):
        self.analysis[&#39;relaxation times tau&#39;] = _extract_tau(self.grid[0], self.grid[1], self.value)

    def write(self):
        Correlation.write(self)
        if self._output_file != &#39;/dev/stdout&#39;:
            with open(self._output_file + &#39;.tau&#39;, &#39;w&#39;) as out:
                _write_tau(out, self.analysis)


class SelfIntermediateScatteringFast(SelfIntermediateScatteringLegacy):
    &#34;&#34;&#34;
    Self part of the intermediate scattering function (fast version)

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;
    def _compute(self):
        from atooms.postprocessing.fourierspace_wrap import fourierspace_module

        # Shortcuts
        pos = numpy.array(self._pos)
        ndims = len(self.k0)
        skip = self.skip

        # Select the f90 kernel
        if ndims == 3:
            fskt_kernel = fourierspace_module.fskt_kernel_3d
        elif ndims == 2:
            fskt_kernel = fourierspace_module.fskt_kernel_2d
        else:
            fskt_kernel = fourierspace_module.fskt_kernel_nd

        # To optimize without wasting too much memory (we have
        # troubles here) we group particles in blocks and tabulate the
        # exponentials over time. This is more memory consuming but we
        # can optimize the inner loop. The esitmated amuount of
        # allocated memory in Mb for the expo array is
        # self.lookup_mb. Note that the actual memory used scales
        # with number of k vectors, system size and number of frames.
        # TODO: why 2?
        kvec_size = 2*self._koffset + 1
        pos_size = numpy.product(pos.shape)
        target_size = self.lookup_mb * 1e6 / 16.  # 16 bytes for a (double) complex
        number_of_blocks = int(pos_size * kvec_size / target_size)
        number_of_blocks = max(1, number_of_blocks)
        block = int(pos[0].shape[0] / float(number_of_blocks))
        block = max(1, block)
        block = min(pos.shape[1], block)

        # Compute ACF
        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        origins = range(0, pos.shape[1], block)
        for j in progress(origins):
            # Tabulate exponentials
            x = expo_sphere(self.k0, self._koffset, pos[:, j:j + block, :])
            xf = numpy.asfortranarray(x)
            for ik, klist in enumerate(self._kvectors):
                for kvec in klist:
                    kvec = numpy.array(kvec, dtype=numpy.int32)
                    for off, i in self._discrete_tgrid:
                        for i0 in range(off, x.shape[0]-i, skip):
                            # Get the actual time difference. steps must be accessed efficiently (cached!)
                            dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                            # Call f90 kernel
                            res = fskt_kernel(xf, i0+1, i0+1+i, kvec+1)
                            acf[ik][dt] += res.real
                            cnt[ik][dt] += x.shape[1]

        # Define grids
        tgrid = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in tgrid]
        self.value = [[acf[k][t] / cnt[k][t] for t in tgrid] for k in range(len(acf))]

        # Normalization
        if self.normalize:
            for k in range(len(self.grid[0])):
                for i in range(len(self.value[k])):
                    self.value[k][i] /= self.value[k][0]


# Defaults to fast
try:
    import atooms.postprocessing.fourierspace_wrap
    SelfIntermediateScattering = SelfIntermediateScatteringFast
except ImportError:
    SelfIntermediateScattering = SelfIntermediateScatteringLegacy


class IntermediateScattering(IntermediateScatteringBase):
    &#34;&#34;&#34;
    Coherent intermediate scattering function.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;fkt&#39;
    short_name = &#39;F(k,t)&#39;
    long_name = &#39;intermediate scattering function&#39;
    phasespace = &#39;pos&#39;

    def __init__(self, trajectory, kgrid=None, tgrid=None, nk=100, dk=0.1, tsamples=60,
                 kmin=1.0, kmax=10.0, ksamples=10, norigins=-1, fix_cm=False, normalize=True):
        super(IntermediateScattering, self).__init__(trajectory, kgrid=kgrid, tgrid=tgrid,
                                                     nk=nk, tsamples=tsamples, dk=dk, kmin=kmin,
                                                     kmax=kmax, ksamples=ksamples, norigins=norigins,
                                                     fix_cm=fix_cm, normalize=normalize)

    def _compute(self):
        # Shortcuts
        nsteps = len(self._pos_0)
        ndims = len(self.k0)

        # Setup k vectors and tabulate densities rho_0, rho_1
        rho_0 = [defaultdict(complex) for _ in range(nsteps)]
        rho_1 = [defaultdict(complex) for _ in range(nsteps)]
        for it in range(nsteps):
            # Tabulate exponentials
            expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[it])
            
            # Optimize a bit here: if there is only one filter (alpha-alpha or total calculation)
            # expo_2 will be just a reference to expo_1
            if self._pos_1 is self._pos_0:
                expo_1 = expo_0
            else:
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[it])

            # Tabulate densities rho_0, rho_1
            for klist in self._kvectors:
                for kvec in klist:
                    if ndims == 3:
                        rho_0[it][kvec] = numpy.sum(expo_0[..., 0, kvec[0]] *
                                                    expo_0[..., 1, kvec[1]] *
                                                    expo_0[..., 2, kvec[2]])
                    elif ndims == 2:
                        rho_0[it][kvec] = numpy.sum(expo_0[..., 0, kvec[0]] *
                                                    expo_0[..., 1, kvec[1]])
                    else:
                        # Arbitrary dimension (a bit slower)
                        tmp = expo_0[..., 0, kvec[0]]
                        for idim in range(1, len(kvec)):
                            tmp *= expo_0[..., idim, kvec[idim]]
                        rho_0[it][kvec] += numpy.sum(tmp).real

                    # Same optimization as above: only calculate rho_1 if needed
                    if self._pos_1 is not self._pos_0:
                        if ndims == 3:
                            rho_1[it][kvec] = numpy.sum(expo_1[..., 0, kvec[0]] *
                                                        expo_1[..., 1, kvec[1]] *
                                                        expo_1[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_1[it][kvec] = numpy.sum(expo_1[..., 0, kvec[0]] *
                                                        expo_1[..., 1, kvec[1]])
                        else:
                            # Arbitrary dimension (a bit slower)
                            tmp = expo_1[..., 0, kvec[0]]
                            for idim in range(1, len(kvec)):
                                tmp *= expo_1[..., idim, kvec[idim]]
                            rho_1[it][kvec] += numpy.sum(tmp).real

            # Optimization
            if self._pos_1 is self._pos_0:
                rho_1 = rho_0

        # Compute correlation function
        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        for ik, klist in enumerate(progress(self._kvectors)):
            for kvec in klist:
                for off, i in self._discrete_tgrid:
                    for i0 in range(off, len(rho_0)-i, self.skip):
                        # Get the actual time difference
                        # TODO: It looks like the order of i0 and ik lopps should be swapped
                        dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                        acf[ik][dt] += (rho_0[i0+i][kvec] * rho_1[i0][kvec].conjugate()).real #/ self._pos[i0].shape[0]
                        cnt[ik][dt] += 1

        # Normalization
        times = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in times]
        # TODO: check normalization when not GC, does not give exactly the short time behavior as pp.x
        # This switch is not used
        # if self._pos_0 is self._pos_1:
        #     nav = sum([p.shape[0] for p in self._pos]) / len(self._pos)
        # else:
        #     nav_0 = sum([p.shape[0] for p in self._pos_0]) / len(self._pos_0)
        #     nav_1 = sum([p.shape[0] for p in self._pos_1]) / len(self._pos_1)
        # First normalize by cnt (time counts), then by value at t=0
        # We do not need to normalize by the average number of particles
        self.value_nonorm = [[acf[k][t] / (cnt[k][t]) for t in times] for k in range(len(acf))]

        # Normalize
        if self.normalize:
            self.value = [[v / self.value_nonorm[k][0] for v in self.value_nonorm[k]] for k in range(len(acf))]
        else:
            self.value = self.value_nonorm

    def analyze(self):
        self.analysis[&#39;relaxation times tau&#39;] = _extract_tau(self.grid[0], self.grid[1], self.value)

    def write(self):
        Correlation.write(self)
        if self._output_file != &#39;/dev/stdout&#39;:
            with open(self._output_file + &#39;.tau&#39;, &#39;w&#39;) as out:
                _write_tau(out, self.analysis)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="postprocessing.fkt.IntermediateScattering"><code class="flex name class">
<span>class <span class="ident">IntermediateScattering</span></span>
<span>(</span><span>trajectory, kgrid=None, tgrid=None, nk=100, dk=0.1, tsamples=60, kmin=1.0, kmax=10.0, ksamples=10, norigins=-1, fix_cm=False, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Coherent intermediate scattering function.</p>
<p>See the documentation of the <code>FourierSpaceCorrelation</code> base class
for information on the instance variables.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntermediateScattering(IntermediateScatteringBase):
    &#34;&#34;&#34;
    Coherent intermediate scattering function.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    nbodies = 2
    symbol = &#39;fkt&#39;
    short_name = &#39;F(k,t)&#39;
    long_name = &#39;intermediate scattering function&#39;
    phasespace = &#39;pos&#39;

    def __init__(self, trajectory, kgrid=None, tgrid=None, nk=100, dk=0.1, tsamples=60,
                 kmin=1.0, kmax=10.0, ksamples=10, norigins=-1, fix_cm=False, normalize=True):
        super(IntermediateScattering, self).__init__(trajectory, kgrid=kgrid, tgrid=tgrid,
                                                     nk=nk, tsamples=tsamples, dk=dk, kmin=kmin,
                                                     kmax=kmax, ksamples=ksamples, norigins=norigins,
                                                     fix_cm=fix_cm, normalize=normalize)

    def _compute(self):
        # Shortcuts
        nsteps = len(self._pos_0)
        ndims = len(self.k0)

        # Setup k vectors and tabulate densities rho_0, rho_1
        rho_0 = [defaultdict(complex) for _ in range(nsteps)]
        rho_1 = [defaultdict(complex) for _ in range(nsteps)]
        for it in range(nsteps):
            # Tabulate exponentials
            expo_0 = expo_sphere(self.k0, self._koffset, self._pos_0[it])
            
            # Optimize a bit here: if there is only one filter (alpha-alpha or total calculation)
            # expo_2 will be just a reference to expo_1
            if self._pos_1 is self._pos_0:
                expo_1 = expo_0
            else:
                expo_1 = expo_sphere(self.k0, self._koffset, self._pos_1[it])

            # Tabulate densities rho_0, rho_1
            for klist in self._kvectors:
                for kvec in klist:
                    if ndims == 3:
                        rho_0[it][kvec] = numpy.sum(expo_0[..., 0, kvec[0]] *
                                                    expo_0[..., 1, kvec[1]] *
                                                    expo_0[..., 2, kvec[2]])
                    elif ndims == 2:
                        rho_0[it][kvec] = numpy.sum(expo_0[..., 0, kvec[0]] *
                                                    expo_0[..., 1, kvec[1]])
                    else:
                        # Arbitrary dimension (a bit slower)
                        tmp = expo_0[..., 0, kvec[0]]
                        for idim in range(1, len(kvec)):
                            tmp *= expo_0[..., idim, kvec[idim]]
                        rho_0[it][kvec] += numpy.sum(tmp).real

                    # Same optimization as above: only calculate rho_1 if needed
                    if self._pos_1 is not self._pos_0:
                        if ndims == 3:
                            rho_1[it][kvec] = numpy.sum(expo_1[..., 0, kvec[0]] *
                                                        expo_1[..., 1, kvec[1]] *
                                                        expo_1[..., 2, kvec[2]])
                        elif ndims == 2:
                            rho_1[it][kvec] = numpy.sum(expo_1[..., 0, kvec[0]] *
                                                        expo_1[..., 1, kvec[1]])
                        else:
                            # Arbitrary dimension (a bit slower)
                            tmp = expo_1[..., 0, kvec[0]]
                            for idim in range(1, len(kvec)):
                                tmp *= expo_1[..., idim, kvec[idim]]
                            rho_1[it][kvec] += numpy.sum(tmp).real

            # Optimization
            if self._pos_1 is self._pos_0:
                rho_1 = rho_0

        # Compute correlation function
        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        for ik, klist in enumerate(progress(self._kvectors)):
            for kvec in klist:
                for off, i in self._discrete_tgrid:
                    for i0 in range(off, len(rho_0)-i, self.skip):
                        # Get the actual time difference
                        # TODO: It looks like the order of i0 and ik lopps should be swapped
                        dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                        acf[ik][dt] += (rho_0[i0+i][kvec] * rho_1[i0][kvec].conjugate()).real #/ self._pos[i0].shape[0]
                        cnt[ik][dt] += 1

        # Normalization
        times = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in times]
        # TODO: check normalization when not GC, does not give exactly the short time behavior as pp.x
        # This switch is not used
        # if self._pos_0 is self._pos_1:
        #     nav = sum([p.shape[0] for p in self._pos]) / len(self._pos)
        # else:
        #     nav_0 = sum([p.shape[0] for p in self._pos_0]) / len(self._pos_0)
        #     nav_1 = sum([p.shape[0] for p in self._pos_1]) / len(self._pos_1)
        # First normalize by cnt (time counts), then by value at t=0
        # We do not need to normalize by the average number of particles
        self.value_nonorm = [[acf[k][t] / (cnt[k][t]) for t in times] for k in range(len(acf))]

        # Normalize
        if self.normalize:
            self.value = [[v / self.value_nonorm[k][0] for v in self.value_nonorm[k]] for k in range(len(acf))]
        else:
            self.value = self.value_nonorm

    def analyze(self):
        self.analysis[&#39;relaxation times tau&#39;] = _extract_tau(self.grid[0], self.grid[1], self.value)

    def write(self):
        Correlation.write(self)
        if self._output_file != &#39;/dev/stdout&#39;:
            with open(self._output_file + &#39;.tau&#39;, &#39;w&#39;) as out:
                _write_tau(out, self.analysis)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>postprocessing.fkt.IntermediateScatteringBase</li>
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.add_filter" href="correlation.html#postprocessing.correlation.Correlation.add_filter">add_filter</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.add_weight" href="correlation.html#postprocessing.correlation.Correlation.add_weight">add_weight</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.analyze" href="correlation.html#postprocessing.correlation.Correlation.analyze">analyze</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.compute" href="correlation.html#postprocessing.correlation.Correlation.compute">compute</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.do" href="correlation.html#postprocessing.correlation.Correlation.do">do</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.grid_name" href="correlation.html#postprocessing.correlation.Correlation.grid_name">grid_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.long_name" href="correlation.html#postprocessing.correlation.Correlation.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.nbodies" href="correlation.html#postprocessing.correlation.Correlation.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.need_update" href="correlation.html#postprocessing.correlation.Correlation.need_update">need_update</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.phasespace" href="correlation.html#postprocessing.correlation.Correlation.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.read" href="correlation.html#postprocessing.correlation.Correlation.read">read</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.report" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation.report">report</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.short_name" href="correlation.html#postprocessing.correlation.Correlation.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.static" href="correlation.html#postprocessing.correlation.Correlation.static">static</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.symbol" href="correlation.html#postprocessing.correlation.Correlation.symbol">symbol</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.write" href="correlation.html#postprocessing.correlation.Correlation.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="postprocessing.fkt.SelfIntermediateScatteringFast"><code class="flex name class">
<span>class <span class="ident">SelfIntermediateScattering</span></span>
<span>(</span><span>trajectory, kgrid=None, tgrid=None, nk=8, tsamples=60, dk=0.1, kmin=1.0, kmax=10.0, ksamples=10, norigins=-1, fix_cm=False, lookup_mb=64.0, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Self part of the intermediate scattering function (fast version)</p>
<p>See the documentation of the <code>FourierSpaceCorrelation</code> base class
for information on the instance variables.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SelfIntermediateScatteringFast(SelfIntermediateScatteringLegacy):
    &#34;&#34;&#34;
    Self part of the intermediate scattering function (fast version)

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;
    def _compute(self):
        from atooms.postprocessing.fourierspace_wrap import fourierspace_module

        # Shortcuts
        pos = numpy.array(self._pos)
        ndims = len(self.k0)
        skip = self.skip

        # Select the f90 kernel
        if ndims == 3:
            fskt_kernel = fourierspace_module.fskt_kernel_3d
        elif ndims == 2:
            fskt_kernel = fourierspace_module.fskt_kernel_2d
        else:
            fskt_kernel = fourierspace_module.fskt_kernel_nd

        # To optimize without wasting too much memory (we have
        # troubles here) we group particles in blocks and tabulate the
        # exponentials over time. This is more memory consuming but we
        # can optimize the inner loop. The esitmated amuount of
        # allocated memory in Mb for the expo array is
        # self.lookup_mb. Note that the actual memory used scales
        # with number of k vectors, system size and number of frames.
        # TODO: why 2?
        kvec_size = 2*self._koffset + 1
        pos_size = numpy.product(pos.shape)
        target_size = self.lookup_mb * 1e6 / 16.  # 16 bytes for a (double) complex
        number_of_blocks = int(pos_size * kvec_size / target_size)
        number_of_blocks = max(1, number_of_blocks)
        block = int(pos[0].shape[0] / float(number_of_blocks))
        block = max(1, block)
        block = min(pos.shape[1], block)

        # Compute ACF
        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        origins = range(0, pos.shape[1], block)
        for j in progress(origins):
            # Tabulate exponentials
            x = expo_sphere(self.k0, self._koffset, pos[:, j:j + block, :])
            xf = numpy.asfortranarray(x)
            for ik, klist in enumerate(self._kvectors):
                for kvec in klist:
                    kvec = numpy.array(kvec, dtype=numpy.int32)
                    for off, i in self._discrete_tgrid:
                        for i0 in range(off, x.shape[0]-i, skip):
                            # Get the actual time difference. steps must be accessed efficiently (cached!)
                            dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                            # Call f90 kernel
                            res = fskt_kernel(xf, i0+1, i0+1+i, kvec+1)
                            acf[ik][dt] += res.real
                            cnt[ik][dt] += x.shape[1]

        # Define grids
        tgrid = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in tgrid]
        self.value = [[acf[k][t] / cnt[k][t] for t in tgrid] for k in range(len(acf))]

        # Normalization
        if self.normalize:
            for k in range(len(self.grid[0])):
                for i in range(len(self.value[k])):
                    self.value[k][i] /= self.value[k][0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy" href="#postprocessing.fkt.SelfIntermediateScatteringLegacy">SelfIntermediateScatteringLegacy</a></li>
<li>postprocessing.fkt.IntermediateScatteringBase</li>
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
</dd>
<dt id="postprocessing.fkt.SelfIntermediateScatteringFast"><code class="flex name class">
<span>class <span class="ident">SelfIntermediateScatteringFast</span></span>
<span>(</span><span>trajectory, kgrid=None, tgrid=None, nk=8, tsamples=60, dk=0.1, kmin=1.0, kmax=10.0, ksamples=10, norigins=-1, fix_cm=False, lookup_mb=64.0, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Self part of the intermediate scattering function (fast version)</p>
<p>See the documentation of the <code>FourierSpaceCorrelation</code> base class
for information on the instance variables.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SelfIntermediateScatteringFast(SelfIntermediateScatteringLegacy):
    &#34;&#34;&#34;
    Self part of the intermediate scattering function (fast version)

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;
    def _compute(self):
        from atooms.postprocessing.fourierspace_wrap import fourierspace_module

        # Shortcuts
        pos = numpy.array(self._pos)
        ndims = len(self.k0)
        skip = self.skip

        # Select the f90 kernel
        if ndims == 3:
            fskt_kernel = fourierspace_module.fskt_kernel_3d
        elif ndims == 2:
            fskt_kernel = fourierspace_module.fskt_kernel_2d
        else:
            fskt_kernel = fourierspace_module.fskt_kernel_nd

        # To optimize without wasting too much memory (we have
        # troubles here) we group particles in blocks and tabulate the
        # exponentials over time. This is more memory consuming but we
        # can optimize the inner loop. The esitmated amuount of
        # allocated memory in Mb for the expo array is
        # self.lookup_mb. Note that the actual memory used scales
        # with number of k vectors, system size and number of frames.
        # TODO: why 2?
        kvec_size = 2*self._koffset + 1
        pos_size = numpy.product(pos.shape)
        target_size = self.lookup_mb * 1e6 / 16.  # 16 bytes for a (double) complex
        number_of_blocks = int(pos_size * kvec_size / target_size)
        number_of_blocks = max(1, number_of_blocks)
        block = int(pos[0].shape[0] / float(number_of_blocks))
        block = max(1, block)
        block = min(pos.shape[1], block)

        # Compute ACF
        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        origins = range(0, pos.shape[1], block)
        for j in progress(origins):
            # Tabulate exponentials
            x = expo_sphere(self.k0, self._koffset, pos[:, j:j + block, :])
            xf = numpy.asfortranarray(x)
            for ik, klist in enumerate(self._kvectors):
                for kvec in klist:
                    kvec = numpy.array(kvec, dtype=numpy.int32)
                    for off, i in self._discrete_tgrid:
                        for i0 in range(off, x.shape[0]-i, skip):
                            # Get the actual time difference. steps must be accessed efficiently (cached!)
                            dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                            # Call f90 kernel
                            res = fskt_kernel(xf, i0+1, i0+1+i, kvec+1)
                            acf[ik][dt] += res.real
                            cnt[ik][dt] += x.shape[1]

        # Define grids
        tgrid = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in tgrid]
        self.value = [[acf[k][t] / cnt[k][t] for t in tgrid] for k in range(len(acf))]

        # Normalization
        if self.normalize:
            for k in range(len(self.grid[0])):
                for i in range(len(self.value[k])):
                    self.value[k][i] /= self.value[k][0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy" href="#postprocessing.fkt.SelfIntermediateScatteringLegacy">SelfIntermediateScatteringLegacy</a></li>
<li>postprocessing.fkt.IntermediateScatteringBase</li>
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy" href="#postprocessing.fkt.SelfIntermediateScatteringLegacy">SelfIntermediateScatteringLegacy</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.add_filter" href="correlation.html#postprocessing.correlation.Correlation.add_filter">add_filter</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.add_weight" href="correlation.html#postprocessing.correlation.Correlation.add_weight">add_weight</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.analyze" href="correlation.html#postprocessing.correlation.Correlation.analyze">analyze</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.compute" href="correlation.html#postprocessing.correlation.Correlation.compute">compute</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.do" href="correlation.html#postprocessing.correlation.Correlation.do">do</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.grid_name" href="correlation.html#postprocessing.correlation.Correlation.grid_name">grid_name</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.lookup_mb" href="#postprocessing.fkt.SelfIntermediateScatteringLegacy.lookup_mb">lookup_mb</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.nbodies" href="correlation.html#postprocessing.correlation.Correlation.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.need_update" href="correlation.html#postprocessing.correlation.Correlation.need_update">need_update</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.read" href="correlation.html#postprocessing.correlation.Correlation.read">read</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.report" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation.report">report</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.static" href="correlation.html#postprocessing.correlation.Correlation.static">static</a></code></li>
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.write" href="correlation.html#postprocessing.correlation.Correlation.write">write</a></code></li>
</ul>
</li>
<li><code><b><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.long_name" href="correlation.html#postprocessing.correlation.Correlation.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.phasespace" href="correlation.html#postprocessing.correlation.Correlation.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.short_name" href="correlation.html#postprocessing.correlation.Correlation.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.symbol" href="correlation.html#postprocessing.correlation.Correlation.symbol">symbol</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="postprocessing.fkt.SelfIntermediateScatteringLegacy"><code class="flex name class">
<span>class <span class="ident">SelfIntermediateScatteringLegacy</span></span>
<span>(</span><span>trajectory, kgrid=None, tgrid=None, nk=8, tsamples=60, dk=0.1, kmin=1.0, kmax=10.0, ksamples=10, norigins=-1, fix_cm=False, lookup_mb=64.0, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Self part of the intermediate scattering function.</p>
<p>See the documentation of the <code>FourierSpaceCorrelation</code> base class
for information on the instance variables.</p>
<p>Possible inputs:</p>
<ol>
<li>kgrid is None:</li>
</ol>
<p>the k grid is determined internally from kmin, kmax, ksamples
and the kvectors are sampled using nk and dk parameters</p>
<ol>
<li>kgrid is not None, via grid or setting the variable after
construction:</li>
</ol>
<p>kvectors are sampled using nk and dk and the kgrid is
eventually redefined so that its values correspond exactly to
the norms of the kvectors in each group</p>
<ol>
<li>kvectors is not None or set after construction: </li>
</ol>
<p>kvectors must be a list of lists of kvectors in natural units</p>
<p>Internal variables:</p>
<ul>
<li>
<p>k0 : norm of the smallest kvector allowed by cell,
determined internally at compute time.</p>
</li>
<li>
<p>_kvectors: list of lists of ndim arrays, grouped by
the averaged norm, whose indices are (ix, iy, iz), which
identify the kvectors according to the following
formulas. We write kvectors as</p>
</li>
</ul>
<p>k = k0 * (jx, jy, jz)</p>
<p>where jx, jy, jz are relative numbers. We tabulate
exponentials over a grid and the indices (ix, iy, iz) of the
tabulated array obey Fortran indexing. We symmetrize the j
indices like this</p>
<p>ix = jx + offset_j + 1, iy = jy + offset_j + 1, iz = jz + offset_j + 1</p>
<p>where offset_j is the absolute value of the minimum of the
whole set of (jx, jy, jz). This way we are sure that indices
start from 1. This is necessary with numpy arrays, for which
negative indices have a different meaning.</p>
<ul>
<li>_koffset: value of offset_j defined above</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SelfIntermediateScatteringLegacy(IntermediateScatteringBase):
    &#34;&#34;&#34;
    Self part of the intermediate scattering function.

    See the documentation of the `FourierSpaceCorrelation` base class
    for information on the instance variables.
    &#34;&#34;&#34;

    symbol = &#39;fskt&#39;
    short_name = &#39;F_s(k,t)&#39;
    long_name = &#39;self intermediate scattering function&#39;
    phasespace = &#39;pos&#39;

    def __init__(self, trajectory, kgrid=None, tgrid=None, nk=8,
                 tsamples=60, dk=0.1, kmin=1.0, kmax=10.0,
                 ksamples=10, norigins=-1, fix_cm=False,
                 lookup_mb=64.0, normalize=True):
        super(SelfIntermediateScatteringLegacy,
              self).__init__(trajectory, kgrid=kgrid, tgrid=tgrid,
                             nk=nk, tsamples=tsamples, dk=dk, kmin=kmin,
                             kmax=kmax, ksamples=ksamples, norigins=norigins,
                             fix_cm=fix_cm, normalize=normalize)
        self.lookup_mb = lookup_mb
        &#34;&#34;&#34;Memory in Mb allocated for exponentials tabulation&#34;&#34;&#34;

    def _compute(self):
        # Shortcuts
        pos = numpy.array(self._pos)
        ndims = len(self.k0)
        skip = self.skip
        # To optimize without wasting too much memory (we have
        # troubles here) we group particles in blocks and tabulate the
        # exponentials over time. This is more memory consuming but we
        # can optimize the inner loop. Even better, we could change
        # the order in the tabulated expo array to speed things up
        # Use 10 blocks, but do not exceed 200 particles
        number_of_blocks = 10
        block = int(pos[0].shape[0] / float(number_of_blocks))
        block = max(20, block)
        block = min(200, block)

        acf = [defaultdict(float) for _ in self.kgrid]
        cnt = [defaultdict(float) for _ in self.kgrid]
        origins = range(0, pos.shape[1], block)
        for j in progress(origins):
            # Tabulate exponentials
            x = expo_sphere(self.k0, self._koffset, pos[:, j:j + block, :])
            for ik, klist in enumerate(self._kvectors):
                for kvec in klist:
                    for off, i in self._discrete_tgrid:
                        for i0 in range(off, x.shape[0]-i, skip):
                            # Get the actual time difference. steps must be accessed efficiently (cached!)
                            dt = self.trajectory.steps[i0+i] - self.trajectory.steps[i0]
                            # Dimensional switch
                            if ndims == 3:
                                acf[ik][dt] += numpy.sum(x[i0+i, :, 0, kvec[0]]*x[i0, :, 0, kvec[0]].conjugate() *
                                                         x[i0+i, :, 1, kvec[1]]*x[i0, :, 1, kvec[1]].conjugate() *
                                                         x[i0+i, :, 2, kvec[2]]*x[i0, :, 2, kvec[2]].conjugate()).real
                            elif ndims == 2:
                                acf[ik][dt] += numpy.sum(x[i0+i, :, 0, kvec[0]]*x[i0, :, 0, kvec[0]].conjugate() *
                                                         x[i0+i, :, 1, kvec[1]]*x[i0, :, 1, kvec[1]].conjugate()).real

                            else:
                                # Arbitrary dimension (a bit slower)
                                tmp = x[i0+i, :, 0, kvec[0]]*x[i0, :, 0, kvec[0]].conjugate()
                                for idim in range(1, len(kvec)):
                                    tmp *= x[i0+i, :, idim, kvec[idim]]*x[i0, :, idim, kvec[idim]].conjugate()
                                acf[ik][dt] += numpy.sum(tmp).real
                            cnt[ik][dt] += x.shape[1]

        # Define grids
        tgrid = sorted(acf[0].keys())
        self.grid[0] = self.kgrid
        self.grid[1] = [ti*self.trajectory.timestep for ti in tgrid]
        self.value = [[acf[k][t] / cnt[k][t] for t in tgrid] for k in range(len(acf))]

        # Normalization
        if self.normalize:
            for k in range(len(self.grid[0])):
                for i in range(len(self.value[k])):
                    self.value[k][i] /= self.value[k][0]

    def analyze(self):
        self.analysis[&#39;relaxation times tau&#39;] = _extract_tau(self.grid[0], self.grid[1], self.value)

    def write(self):
        Correlation.write(self)
        if self._output_file != &#39;/dev/stdout&#39;:
            with open(self._output_file + &#39;.tau&#39;, &#39;w&#39;) as out:
                _write_tau(out, self.analysis)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>postprocessing.fkt.IntermediateScatteringBase</li>
<li><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></li>
<li><a title="postprocessing.correlation.Correlation" href="correlation.html#postprocessing.correlation.Correlation">Correlation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="postprocessing.fkt.SelfIntermediateScatteringFast" href="#postprocessing.fkt.SelfIntermediateScatteringFast">SelfIntermediateScatteringFast</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="postprocessing.fkt.SelfIntermediateScatteringLegacy.lookup_mb"><code class="name">var <span class="ident">lookup_mb</span></code></dt>
<dd>
<div class="desc"><p>Memory in Mb allocated for exponentials tabulation</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="postprocessing.fourierspace.FourierSpaceCorrelation" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation">FourierSpaceCorrelation</a></b></code>:
<ul class="hlist">
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.add_filter" href="correlation.html#postprocessing.correlation.Correlation.add_filter">add_filter</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.add_weight" href="correlation.html#postprocessing.correlation.Correlation.add_weight">add_weight</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.analyze" href="correlation.html#postprocessing.correlation.Correlation.analyze">analyze</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.compute" href="correlation.html#postprocessing.correlation.Correlation.compute">compute</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.do" href="correlation.html#postprocessing.correlation.Correlation.do">do</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.grid_name" href="correlation.html#postprocessing.correlation.Correlation.grid_name">grid_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.long_name" href="correlation.html#postprocessing.correlation.Correlation.long_name">long_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.nbodies" href="correlation.html#postprocessing.correlation.Correlation.nbodies">nbodies</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.need_update" href="correlation.html#postprocessing.correlation.Correlation.need_update">need_update</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.phasespace" href="correlation.html#postprocessing.correlation.Correlation.phasespace">phasespace</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.read" href="correlation.html#postprocessing.correlation.Correlation.read">read</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.report" href="fourierspace.html#postprocessing.fourierspace.FourierSpaceCorrelation.report">report</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.short_name" href="correlation.html#postprocessing.correlation.Correlation.short_name">short_name</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.static" href="correlation.html#postprocessing.correlation.Correlation.static">static</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.symbol" href="correlation.html#postprocessing.correlation.Correlation.symbol">symbol</a></code></li>
<li><code><a title="postprocessing.fourierspace.FourierSpaceCorrelation.write" href="correlation.html#postprocessing.correlation.Correlation.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="postprocessing" href="index.html">postprocessing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="postprocessing.fkt.IntermediateScattering" href="#postprocessing.fkt.IntermediateScattering">IntermediateScattering</a></code></h4>
</li>
<li>
<h4><code><a title="postprocessing.fkt.SelfIntermediateScatteringFast" href="#postprocessing.fkt.SelfIntermediateScatteringFast">SelfIntermediateScatteringFast</a></code></h4>
</li>
<li>
<h4><code><a title="postprocessing.fkt.SelfIntermediateScatteringFast" href="#postprocessing.fkt.SelfIntermediateScatteringFast">SelfIntermediateScatteringFast</a></code></h4>
</li>
<li>
<h4><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy" href="#postprocessing.fkt.SelfIntermediateScatteringLegacy">SelfIntermediateScatteringLegacy</a></code></h4>
<ul class="">
<li><code><a title="postprocessing.fkt.SelfIntermediateScatteringLegacy.lookup_mb" href="#postprocessing.fkt.SelfIntermediateScatteringLegacy.lookup_mb">lookup_mb</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>